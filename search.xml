<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[npm 的一个小细节]]></title>
    <url>%2F2017%2F05%2F20%2Fnpm-two%2F</url>
    <content type="text"><![CDATA[在使用 electron 构建桌面应用的时候，在 package.json 里面的 scripts 字段是这样的123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot;&#125;, 我们可以执行 npm start ，那么它就会执行 electron . 这个命令。那么如果我们直接执行 electron .由于我们没有将 electron 加入到全局，所以不行。那么为什么 npm start 可以执行呢？ 这就涉及到 npm run 命令的一个小细节了。npm run xxx 可以执行 package.json 里面 scripts 里面对应的命令，并且是 shell 脚本。但是在执行的时候有一个小处理： npm run 新建的这个 shell ，会将当前目录的 node_modules/.bin 子目录加入 PATH 变量，执行结束后，再将 PATH 变量恢复原样。 这就解释了，没有安装全局的 electron ，直接运行 electron . 是不行的，但是使用 npm start 来运行 electron . 可以。 下面介绍一个使用 npm 的实践：很多朋友使用 hexo 来构建博客；hexo 是基于 Node.js 产物，用它发表博文，很是方便；你只需 hexo clean, hexo g, hexo d三个命令即可；而且每一个命令必须等待前一个命令运行完成。文章数据一多，一套命令打下来，也得 20s+；如果略懂 npm，在 package.js 中加入点命名，例如像这样；123"scripts": &#123; "start": "sudo hexo clean &amp;&amp; sudo hexo g &amp;&amp; sudo gulp &amp;&amp; sudo hexo d"&#125; 那么 只需运行 npm start 就好，可将时间消耗缩短至 2s节省时间虽说不多，却也是数量级的提升，而且代价只是那么小，并一劳永逸。所以有必要对此。 关于 npm 的详细学习，可以查看：npm 全面介绍]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp 详解与使用]]></title>
    <url>%2F2017%2F05%2F01%2Fgulp%2F</url>
    <content type="text"><![CDATA[什么是 gulpgulp 是一个前端构建工具，它能通过自动执行常见任务，比如编译预处理 CSS ，压缩 JavaScript 和刷新浏览器，来改进网站开发的过程，从而使开发更加快速高效。 为什么要用 gulp与 grunt 相比，gulp 无需写一大堆繁杂的配置参数，API（中文 API） 也非常简单，学习起来很容易，而且 gulp 使用的是 nodejs 中 stream 来读取和操作数据，其速度更快。gulp 有庞大的生态圈，且每天都在发展。依靠成千上万可供选择的插件，你可以利用 gulp 自动完成几乎任何事。 如何使用 gulpInstalling Gulp新版的 gulp 命令行工具已经改名为 gulp-cli 。如果你之前安装了全局的 gulp 。在使用新的 gulp-cli 之前，执行命令 npm rm --global gulp ，将之前的全局 gulp 卸掉。 Install the gulp command1npm install --global gulp-cli Install gulp in your devDependenciesRun this command in your project directory1npm install --save-dev gulp Create a gulpfileCreate a file called gulpfile.js in your project root with these contents:12345var gulp = require('gulp');gulp.task('default', function() &#123; // place code for your default tash here&#125;); Test it outRun the gulp command in your projct directory:1gulp gulp APIgulp 的核心 API 有四个：gulp.task() 、 gulp.src() 、 gulp.dest() 、 gulp.watch() 。gulp APIgulp API 中文 下面详细介绍一下： gulp.src()gulp.src() 可以读取你需要操作的文件，相比于 Grunt 主要以文件为媒介来运行它的工作流，gulp 使用的是 Nodejs 中的 stream 流，首先获取到需要的 stream ，然后可以通过 stream 的 pipe() 方法把流导入到你想要的地方，比如 gulp 的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以 gulp 是以 stream 为媒介的，它不需要频繁的生成临时文件，这也是 gulp 的速度比 Grunt 快的一个原因。再回到正题上来，gulp.src() 方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流（Vinyl files），这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，这个我们暂时不用去深入理解，你只需简单的理解可以用这个方法来读取你需要操作的文件就行了。其语法为：1gulp.src(globs [, options]) gulp 用到的 glob 的匹配规则以及一些文件匹配技巧。gulp 内部使用了 node-glob 模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件： * 匹配文件路径中的 0 个或多个字符，但不会匹配路径分配符，除非路径分隔符出现在末尾 ** 匹配路径中的 0 个或多个目录及其子目录，需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。 ? 匹配文件路径中的一个字符（不会匹配路径分隔符） […] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为 ^ 或 ! 时，则表示不匹配方括号中出现的其他字符中的任意一个，类似 js 正则表达式中的用法。 !(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的 ?(pattern|pattern|pattern) 匹配括号中给定的任一模式 0 次或 1 次，类似于 js 正则中的(pattern|pattern|pattern)? +(pattern|pattern|pattern) 匹配括号中给定的任一模式至少 1 次，类似于正则中的(pattern|pattern|pattern)+ *(pattern|pattern|pattern) 匹配括号中的给定的任一模式 0 次或多次，类似于 js 正则中的 (pattern|pattern|pattern)* @(pattern|pattern|pattern) 匹配括号中给定的任一模式 1 次，类似于 js 正则中的(pattern|pattern|pattern) 下面以一系列例子来加深理解 * 能匹配 a.js 、 x.y 、 abc 、 abc/ ，但不能匹配 a/b.js *.* 能匹配 a.js 、 style.css 、 a.b 、 x.y */*/*.js 能匹配 a/b/c.js 、 x/y/z.js ，不能匹配 a/b.js 、a/b/c/d.js ** 能匹配 abc 、 a/b.js 、 a/b/c.js 、 x/y/z 、x/y/z/a.b ，能用来匹配所有的目录和文件 */.js 能匹配 foo.js 、 a/foo.js 、 a/b/foo.js 、 a/b/c/foo.js a/**/z 能匹配 a/z 、 a/b/z 、 a/b/c/z 、 a/d/g/h/r/z a/**b/z 能匹配 a/b/z 、 a/fb/z ，但不能匹配 a/x/gb/z ，因为只有单 ** 单独出现才能匹配多级目录 ?.js 能匹配 a.js 、 b.js 、 c.js a?? 能匹配 a.b 、 abc ，但不能匹配 ab/ ，因为它不会匹配路径分隔符 [xyz].js 只能匹配 x.js 、 y.js 、 z.js ，不会匹配 xy.js 、 xyz.js 等，整个中括号只代表一个字符 [^xyz].js 能匹配 a.js 、 b.js 、 c.js 等，不能匹配 x.js 、 y.js 、 z.js 当有多种匹配模式时可以使用数组12// 使用数组的方式来匹配多种文件gulp.src(['js/*.js','css/*.css','*.html']) 使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上 ! 即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式12gulp.src([*.js,'!b*.js']) //匹配所有 js 文件，但排除掉以 b 开头的 js 文件gulp.src(['!b*.js',*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中 此外，还可以使用展开模式。展开模式以花括号作为定界符，根据它里面的内容，会展开为多个模式，最后匹配的结果为所有展开的模式想加起来得到的结果。展开的例子如下： a{b,c}d 会展开为 abd 、 acd a{b,}c 会展开为 abc 、 ac a{0..3}d 会展开为 a0d 、 a1d 、 a2d 、 a3d a{b,c{d,e}f}g 会展开为 abg 、 acdfg 、 acefg a{b,c}d{e,f}g 会展开为 abdeg 、 acdeg 、 abdfg 、 abdeg gulp.dest()gulp.dest() 方法是用来写文件的，其语法为：1gulp.dest(path[, options]) path 为写入文件的路径我们给 gulp.dest() 传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当作是目录名，例如：123var gulp = require("gulp");gulp.src("script/jquery.js").pipe(gulp.dest("dist/foo.js"));// 最终生成的文件路径为 dist/foo.js/jquery.js ，而不是 dist/foo.js 要想改变文件名，可以使用插件 gulp-rename下面说说生成的文件路径与我们给 gulp.dest() 方法传入的路径参数之间的关系。gulp.dest(path) 生成的文件路径是我们传入的 path 参数后面再加上 gulp.src() 中有通配符开始出现的那部分路径。例如：12345var gulp = require("gulp");//有通配符开始出现的那部分路径为 **/*.jsgulp.src("script/**/*.js").pipe(gulp.dest("dist"));//最后生成的文件路径为 dist/**/*.js//如果 **/*.js 匹配到的文件为 jquery/jquery.js ，则生成的文件路径为 dist/jquery/jquery.js 再举更多一点的例子123456789101112gulp.src("script/avalon/avalon.js").pipe(gulp.dest("dist"));//没有通配符出现的情况，最后生成的文件路径为 dist/avalon.jsgulp.src("script/**/underscore.js").pipe(gulp.dest("dist"));//有通配符开始出现的那部分路径为 **/underscore.js//假设匹配到的文件为script/util/underscore.js//则最后生成的文件路径为dist/util/underscore.jsgulp.src("script/*").pipe(gulp.dest("dist"));//有通配符出现的那部分路径为*//假设匹配到的文件为script/zepto.js//则最后生成的文件路径为dist/zepto.js 通过指定 gulp.src() 方法配置参数中的 base 属性，我们可以灵活的来改变 gulp.dest() 生成的文件路径。当我们没有在 gulp.src() 方法配置参数中的 base 属性，base 的默认值为通配符开始出现之前那部分路径，例如：1gulp.src("app/src/**/*.css") //此时base的值为 app/src 上面我们说的 gulp.dest() 所生成的文件路径的规则，其实也可以理解成，用我们给 gulp.dest() 传入的路径替换掉 gulp.src() 中的 base 路径，最终得到生成文件的路径。1234gulp.src("app/src/**/*.css").pipe(gulp.dest("dist"));//此时base的值为app/src，也就是说它的base路径为app/src//设该模式匹配到了文件app/src/css/normal.css//用dist替换掉base路径，最终得到dist/css/normal.css 所以改变 base 路径后，gulp.dest() 生成的文件路径也会改变123456789gulp.src("script/lib/*.js").pipe(gulp.dest("build"));//没有配置base参数，此时默认的base路径为script/lib//假设匹配到的文件为script/lib/jquery.js//生成的文件路径为build/jquery.jsgulp.src("script/lib/*.js", &#123;base: "script"&#125;).pipe(gulp.dest("build"));//配置了base参数，此时base路径为script//假设匹配到的文件为script/lib/jquery.js//此时生成的文件路径为build/lib/jquery.js 用 gulp.dest() 把文件流写入文件后，文件流仍然可以继续使用。 gulp.task()gulp.task 方法用来定义任务，内部使用的是 Orchestrator ，其语法为：1gulp.task(name[, deps], fn) name 为任务名，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空个。deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数。fn 为任务函数，我们把任务要执行的代码都要写在里面。该参数也是可选的。1234gulp.task("mytask", ["array", "of", "task", "names"], function() &#123; //定义一个有依赖的任务 // Do something&#125;); 关于 gulp.task() ，我们需要知道执行多个任务时怎么来控制任务执行的顺序。gulp 中执行多个任务，可以通过任务依赖来实现。例如我想要执行 one ，two ，three 这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：12//只要执行default任务，就相当于把one,two,three这三个任务执行了gulp.task('default',['one','two','three']); 如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。但是如果某个任务所依赖的任务是异步的，就要注意了，gulp 并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：1234567891011gulp.task('one', function()&#123; // one是一个异步执行的任务 setTimeout(function()&#123; console.log("one is done"); &#125;,3000);&#125;);//two任务虽然依赖于one任务，但并不会等到one任务中的异步操作完成后再执行gulp.task("two", ["one"], function()&#123; console.log("two is done");&#125;); 上面的例子中我们执行 two 任务时，会先执行 one 任务，但不会去等待 one 任务中的异步操作完成后再执行 two 任务，而是紧接着执行 two 任务。因为 one 任务耗时 5 秒，所以 two 任务会在 one 任务中的异步操作完成之前就执行了。 那如果我们想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？有三种方法可以实现： 第一：在异步操作完成后执行一个回调函数来通知 gulp 这个异步任务已经完成，这个回调函数就是任务函数的第一个参数。12345678910111213gulp.task("one", function(cb) &#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 setTimeout(function()&#123; console.log("one is done"); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;);//这时two任务会在one任务中的异步操作完成后再执行gulp.task("two", ["one"], function()&#123; console.log("two is done");&#125;); 第二：定义任务时返回一个流对象。适用于任务就是操作 gulp.src 获取到的流的情况。1234567891011gulp.task("one", function(cb) &#123; var stream = gulp.src("client/**/*.js") .pipe(dosomething()) //dosomething()中有某些异步操作 .pipe(gulp.dest("build")); return stream;&#125;);// 这是two任务会在one任务中的异步操作完成后再执行gulp.task("two", ["one"], function()&#123; console.log("two is done");&#125;); 第三：返回一个 promise 对象，例如：12345678910111213var Q = require('q'); //一个著名的异步处理的库 https://github.com/kriskowal/qgulp.task("one", function(cb)&#123; var deferred = Q.defer(); //做一些异步操作 setTimeout(function()&#123; deferred.resolve(); &#125;,5000); return deferred.promise;&#125;);gulp.task("two", ["one"], function() &#123; console.log("two is done");&#125;); 关于 gulp.task() ，主要的就是要清除当依赖异步任务时要如何处理。 gulp.watch()gulp.watch() 用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为：1gulp.watch(glob[, opts], tasks); glob 为要监视的文件匹配模式，规则和用法与 gulp.src() 方法中的 glob 相同。opts 为一个可选的配置对象，通常不需要用到。tasks 为文件变化后要执行的任务，为一个数组1234567gulp.task("uglify", function() &#123; //do something&#125;);gulp.task("reload", function() &#123; //do something&#125;);gulp.watch("js/**/*.js", ["uglify","reload"]); gulp.watch(glob [,opts, cb])glob 和 opts 参数与第一种用法相同cb 参数为一个函数。每当监视的文件发生变化时，就会调用这个函数，并且会给它传入一个对象，该对象包含了文件变化的一些信息，type 属性为变化的类型，可以是 added 、changed 、deleted ，path 属性为发生变化的文件的路径1234gulp.watch("js/**/*.js", function(event)&#123; console.log(event.type); //变化类型added为新增，deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径&#125;); gulp 的插件gulp 本身虽然不能完成很多任务，但它有大量插件可用，我们可以在 插件页面 或者在 npm 搜索 gulpplugin 。列一些很棒的 plugin ： JSHint ： js代码检查分析工具 gulp-coffee ： 编译CoffeeScript gulp-mocha ： 执行Mocha测试 gulp-bump ： 更新版本号 gulp-sass ： sass 编译 browser-sync ： 浏览器自动刷新 gulp-uglify ： 代码压缩 gulp-concat ： 合并 gulp-eslint ： 支持 ES6 JSX gulp 命令行参数 -v 或 --version 会显示全局和项目本地所安装的 gulp 版本号 --require &lt;module path&gt; 将会在执行之前 require 一个模块。这对于一些语言编译器或者需要其他应用的情况来说很有用。你可以使用多个 --require --gulpfile &lt;gulpfile path&gt; 手动指定一个 gulpfile 的路径，这在你有很多个 gulpfile 的时候很有用。这也会将 CWD 设置到该 gulpfile 所在目录 --cwd &lt;dir path&gt; 手动指定 CWD 。定义 gulpfile 查找的位置，此外，所有的相应的依赖（require）会从这里开始计算相对路径 -T 或 --tasks 会显示所指定 gulpfile 的 task 依赖树 --tasks-simple 会以纯文本的方式显示所载入的 gulpfile 中的 task 列表 --color 强制 gulp 和 gulp 插件显示颜色，即便没有颜色支持 --no-color 强制不显示颜色，即便检测到有颜色支持 --silent 禁止所有的 gulp 日志 命令行会在 process.env.INIT_CW 中记录它是从哪里被运行的。 tip1、gulp 写进项目 package.json 文件的依赖有什么作用方便别人查看你项目中有些什么依赖，而且在项目目录下执行 npm install 命令会安装项目 package.json 中的所有依赖模块，这样就能简化项目的安装程序了，不用一个一个模块去安装啊。 2、gulp 中着重了解 gulp.task() 如何处理依赖任务是耗时操作或者异步操作的情况。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 全面介绍]]></title>
    <url>%2F2017%2F04%2F10%2Fnpm%2F</url>
    <content type="text"><![CDATA[什么是 NPMnpm 之于 Node.js ，就像 pip 之于 Python， gem 之于 Ruby， pear 之于 PHP 。 npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。 为什么要使用 NPMnpm 是随同 Node.js 一起安装的包管理工具，能解决 Node.js 代码部署上的很多问题，常见的场景有以下几种： 允许用户从 npm 服务器下载别人编写的第三方包到本地使用。 允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。 npm 的背后，是基于 couchdb 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 如何使用 NPM安装npm 不需要单独安装。在安装 Node 的时候，会连带一起安装 npm 。但是，Node 附带的 npm 可能不是最新版本，最后用下面的命令，更新到最新版本。1$ sudo npm install npm@latest -g 如果是 Window 系统使用以下命令即可：1npm install npm -g 也就是使用 npm 安装自己。之所以可以这样，是因为 npm 本身与 Node 的其他模块没有区别。 然后，运行下面的命令，查看各种信息。1234567891011# 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l 使用npm initnpm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。1$ npm init -y npm setnpm set 用来设置环境变量1234$ npm set init-author-name 'Your name'$ npm set init-author-email 'Your email'$ npm set init-author-url 'http://yourdomain.com'$ npm set init-license 'MIT' 上面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json 的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。 npm infonpm info 命令可以查看每个模块的具体信息。比如，查看 underscore 模块的信息。1$ npm info underscore 上面命令返回一个 JavaScript 对象，包含了 underscore 模块的详细信息。这个对象的每个成员，都可以直接从 info 命令查询。12345$ npm info underscore description$ npm info underscore homepage$ npm info underscore version npm searchnpm search 命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。1$ npm search &lt;搜索词&gt; npm listnpm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。1234567$ npm list# 加上 global 参数，会列出全局安装的模块$ npm list -global# npm list 命令也可以列出单个模块$ npm list underscore npm install使用 npm 安装包的命令格式为：npm [install/i] [package_name] 本地模式和全局模式npm 在默认情况下会从 http://npmjs.org 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。如果你熟悉 Ruby 的 gem 或者 Python 的 pip，你会发现 npm 与它们的行为不同，gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。 我们在使用 supervisor 的时候使用了 npm install -g supervisor 命令，就是以全局模式安装 supervisor 。 这里注意一点的就是，supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 npm config set prefix &quot;路径&quot; 安装完以后就可以用 supervisor 来启动服务了。supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node.js 。 一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为本地模式不会注册 PATH 环境变量。“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。 本地模式和全局模式的特点如下： 模式 可通过 require 使用 注册 PATH 本地模式 是 否 全局模式 否 是 123456# 本地安装$ npm install &lt;package name&gt;# 全局安装$ sudo npm install -global &lt;package name&gt;$ sudo npm install -g &lt;package name&gt; npm install 也支持直接输入 Github 代码库地址。12$ npm install git://github.com/package/path.git$ npm install git://github.com/package/path.git#0.1.0 安装之前，npm install 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用 -f 或 –force 参数。1$ npm install &lt;packageName&gt; --force 安装不同版本install 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。123$ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@"&gt;=0.1.0 &lt;0.2.0" install 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。 –save：模块名将被添加到 dependencies，可以简化为参数-S。–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。 12345$ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D dependencies 依赖这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 markdown-it 这个包，版本是 ^8.1.0 ，代表最小依赖版本是 8.1.0 ，如果这个包有更新，那么当我们使用 npm install 命令的时候，npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。123"dependencies": &#123; "markdown-it": "^8.1.0"&#125; devDependencies 开发依赖在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。1234567891011"devDependencies": &#123; "autoprefixer": "^6.4.0",0", "babel-preset-es2015": "^6.0.0", "babel-preset-stage-2": "^6.0.0", "babel-register": "^6.0.0", "webpack": "^1.13.2", "webpack-dev-middleware": "^1.8.3", "webpack-hot-middleware": "^2.12.2", "webpack-merge": "^0.14.1", "highlightjs": "^9.8.0"&#125; 当你有了一个完整的 package.json 文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 npm install 就可以很方便的下载好这个模块所需要的包。 npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用 –production 参数，可以只安装 dependencies 字段的模块。123$ npm install --production# 或者$ NODE_ENV=production npm install 一旦安装了某个模块，就可以在代码中用 require 命令加载这个模块。12var backbone = require('backbone')console.log(backbone.VERSION) npm runnpm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。package.json123456789101112&#123; "name": "myproject", "devDependencies": &#123; "jshint": "latest", "browserify": "latest", "mocha": "latest" &#125;, "scripts": &#123; "lint": "jshint **.js", "test": "mocha test/" &#125;&#125; scripts 脚本顾名思义，就是一些脚本代码，可以通过 npm run script-key 来调用，例如在这个 package.json 的文件夹下使用 npm run dev 就相当于运行了 node build/dev-server.js 这一段代码。使用 scripts 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。npm run 是 npm run-script 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。 123456789// 脚本"scripts": &#123; "dev": "node build/dev-server.js", "build": "node build/build.js", "docs": "node build/docs.js", "build-docs": "npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m 'auto-pages' &amp; git push &amp; git checkout master", "build-publish": "rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push", "lint": "eslint --ext .js,.vue src"&#125; npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。npm 内置了两个命令简写， npm test 等同于执行 npm run test，npm start 等同于执行 npm run start。 1"build": "npm run build-js &amp;&amp; npm run build-css" 上面的写法是先运行 npm run build-js ，然后再运行 npm run build-css ，两个命令中间用 &amp;&amp; 连接。如果希望两个命令同时平行执行，它们中间可以用 &amp; 连接。 写在 scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。1234#!/bin/bashcd site/mainbrowserify browser/main.js | uglifyjs -mc &gt; static/bundle.js 假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。1"build-js": "bin/build.sh" pre- 和 post- 脚本npm run 为每条命令提供了 pre- 和 post- 两个钩子（hook）。以 npm run lint 为例，执行这条命令之前，npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行 npm run prelint，然后执行 npm run lint，最后执行 npm run postlint。12345678910111213&#123; "name": "myproject", "devDependencies": &#123; "eslint": "latest" "karma": "latest" &#125;, "scripts": &#123; "lint": "eslint --cache --ext .js --ext .jsx src", "test": "karma start --log-leve=error karma.config.js --single-run=true", "pretest": "npm run lint", "posttest": "echo 'Finished running tests'" &#125;&#125; 上面代码是一个 package.json 文件的例子。如果执行 npm test，会按下面的顺序执行相应的命令。 pretest test posttest 如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。 npm binnpm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。123# 项目根目录下执行$ npm bin./node_modules/.bin 创建全局链接npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 npm install -g express 安装了 express，这时在工程的目录下运行命令：npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。 创建包包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。Node.js 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征：。package.json 必须在包的顶层目录下；。二进制文件应该在 bin 目录下；。JavaScript 代码应该在 lib 目录下；。文档应该在 doc 目录下；。单元测试应该在 test 目录下。 Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。 我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。 Node.js 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。 package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段：name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。description: 包的简要说明。version: 符合语义化版本识别规范的版本字符串。keywords: 关键字数组，通常用于搜索。maintainers: 维护者数组，每个元素要包含 name 、email(可选)、web(可选)字段。contributors: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。bugs: 提交 bug 的地址，可以是网址或者电子邮件地址。licenses: 许可证数组，每个元素要包含 type（许可证的名称）和 url（链接到许可证文本的地址）字段。repositories: 仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。 包的发布通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建完成后可以使用 npm whoami 检测是否已经取得了账号。接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问 http://search.npmjs.org/ 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule 命令来安装它。如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish 命令就行了。如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。 需要说明的是：json 文件不能有注释 参考链接http://javascript.ruanyifeng.com/nodejs/npm.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS 详细介绍]]></title>
    <url>%2F2017%2F03%2F07%2Fcommonjs%2F</url>
    <content type="text"><![CDATA[CommonJS 规范与实现正如当年为了统一 JavaScript 语言标准，人们制定了 ECMAScript 规范一样，如今为了统一 JavaScript 在浏览器之外的实现，CommonJS 诞生了。CommonJS 试图定义一套普通应用程序使用的 API，从而填补 JavaScript 标准库过于简单的不足。CommonJS 的终极目标是制定一个像 C++ 标准库一样的规范，使得基于 CommonJS API 的应用程序可以在不同的环境下运行，就像用 C++ 编写的应用程序可以使用不同的编译器和运行时函数库一样。为了保持中立，CommonJS 不参与标准库实现，其实现交给像 Node.js 之类的项目来完成。下图是 CommonJS 的各种实现。 CommonJS 规范包括了模块（modules）、包（packages）、系统（system）、二进制（binary）、控制台（console）、编码（encodings）、文件系统（filesystems）、套接字（sockets）、单元测试（unit testing）等部分。 Node.js 是目前 CommonJS 规范最热门的一个实现，它基于 CommonJS 的 Modules/1.0 规范实现了 Node.js 的模块，同时随着 CommonJS 规范的更新，Node.js 也在不断跟进。 模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正式为了实现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的 script 标签来实现。Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。 CommonJS 规范的实现Node.js 的模块和包机制的实现参照了 CommonJS 的标准，但并未完全遵循。不过两者的区别不大，一般来说你大可不必担心，只有当你试图制作一个除了支持 Node.js 之外还要支持其他平台的模块或包的时候才需要仔细研究。通常，两者没有直接冲突的地方。 我们经常把 Node.js 的模块和包相提并论，因为模块和包是没有本质区别的，两个概念也时常混用。如果要辨析，那么可以把包理解成是实现了某个功能模块的集合，用于发布和维护。对使用者来说，模块和包的区别是透明的，因此经常不作区分。 CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。 为了方便，Node.js 为每个模块提供一个 exports 变量，指向 module.exports。这等同在每个模块头部，有一行这样的命令：1var exports = module.exports; 注意，不能直接将 exports 变量指向一个值，因为这样等于切断了 exports 与 module.exports 的联系。 如果你觉得，exports 与 module.exports 之间的区别很难分清，一个简单的处理办法，就是放弃使用 exports，只使用 module.exports。 什么是模块模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。 创建及加载模块创建模块在 Node.js 中，创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问题仅仅在于如何在其他文件中获取这个模块。Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。让我以一个例子来了解模块。创建一个 module.js 文件，内容是：12345678// module.jsvar name;exports.setName = function(thyName) &#123; name = thyName;&#125;;exports.sayHello = function() &#123; console.log('Hello ' + name);&#125;; 在同一目录下创建 getmodule.js，内容是： 1234// getmodule.jsvar myModule = require('./module');myModule.setName('Yu');myModule.sayHello(); 运行 node getmodule.js ，结果是： Hello Yu module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访问接口，在 getmodule.js 中通过 require(&#39;./module&#39;) 加载这个模块，然后就可以直接访问 module.js 中 exports 对象的成员函数了。 加载模块 在 Node.js 中，我们可以直接通过 require 获取核心模块，例如 require(&#39;fs&#39;) 。核心模块拥有最高的加载优先级，换言之如果有模块与其命名冲突，Node.js 总是会加载核心模块。 如果有模块与核心模块命名冲突，Node.js 为什么可以选择加载核心模块呢？require 的实现机制是怎样的呢？ 1、按路径加载模块如果 require 参数以 “/“ 开头，那么就以绝对路径的方式查找模块名称，例如 require(&#39;/home/neveryu/module&#39;) 将会按照 优先级依次尝试加载 /home/neveryu/module.js、/home/neveryu/module.json 和 /home/neveryu/module.node。 如果 require 参数 “./“ 或 “../“ 开头，那么则以相对路径的方式查找模块，这种方式在应用中是最常见的。例如前面的例子中我们用了 require(&#39;./hello&#39;)来加载同一文件夹下的 hello.js。 2、通过查找 node_modules 目录加载模块如果 require 参数不以 “/“ ， “./“ 或 “../“ 开头，而该模块又不是核心模块，那么就要通过查找 node_modules 加载模块了。我们使用 npm 获取的包通常就是以这种方式加载的。在 node_modules 目录的外面一层，外面可以直接使用 require(&#39;express&#39;) 来代替 require(&#39;./node_modules/express&#39;)。这是 Node.js 模块加载的一个重要特征：通过查找 node_modules 目录来加载模块。我们不仅要在 project 目录下的 app.js 中使用 require(&#39;express&#39;)，而且可能要在 controllers 子目录下的 index_controller.js 中也使用 require(&#39;express&#39;)，这时就需要向父目录上溯一层才能找到 node_modules 中的 express 了。 3、加载缓存Node.js 通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。注意，Node.js 是根据实际文件名缓存的，而不是 require() 提供的参数缓存的，也就是说即使你分别通过 require(&#39;express&#39;) 和 require(&#39;./node_modules/express&#39;)加载两次，也不会重复加载，因为尽管两次参数不同，解析到的文件却是同一个。 单次加载上面这个例子有点类似于创建一个对象，但实际上和对象又有本质的区别，因为 require 不会重复加载模块，也就是说无论调用多少次 require，获得的模块都是同一个。我们在 getmodule.js 的基础上稍作修改：12345678// loadmodule.jsvar hello1 = require('./module');hello1.setName('Yu');var hello2 = require('./module');hello2.setName('Yu 2');hello1.sayHello(); 运行后发现输出结果是 Hello Yu 2，这是因为变量 hello1 和 hello2 指向的是同一个实例，因此 hello1.setName 的结果被 hello2.setName 覆盖，最终输出结果是由后者决定的。 覆盖 exports有时候我们只是想把一个对象封装到模块中，例如：123456789101112// singleobjct.jsfunction Hello() &#123; var name; this.setName = function (thyName) &#123; name = thyName; &#125;; this.sayHello = function () &#123; console.log('Hello ' + name); &#125;;&#125;exports.Hello = Hello; 此时我们在其他文件中需要通过 require(&#39;./singleobject&#39;).Hello 来获取 Hello 对象，这略显冗余，可以用下面方法稍微简化。1234567891011// hello.jsfunction Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log('Hello ' + name); &#125;;&#125;module.exports = Hello; 这样就可以直接获得这个对象了：12345// gethello.jsvar Hello = require('./hello');hello = new Hello();hello.setName('Yu');hello.sayHello(); TipCommonJS 模块的特点如下： 所有代码都运行在模块作用域，不会污染全局作用域。 独立性是模块的重要特点就，模块内部最好不与程序的其他部分直接交互。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 CommonJS 中的 Require建议阅览：CommonJS require 规范]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 内存管理 & 垃圾回收机制]]></title>
    <url>%2F2017%2F02%2F18%2Fjs-memory-management-and-gc%2F</url>
    <content type="text"><![CDATA[简介低级语言，比如C，有低级的内存管理基元，像 malloc()，free()。另一方面，JavaScript 的内存基元在变量（对象，字符串等等）创建时分配，然后在他们不再被使用时“自动释放”。后者被称为垃圾回收。这个“自动”是混淆并给 JavaScript （和其他高级语言）开发者一个错觉：他们可以不用考虑内存管理。 JavaScript 的内存分配变量初始化为了不让程序员为分配费心，JavaScript 在定义变量时完成内存分配。例如：123456789101112var n = 123; // 给数值变量分配内存// 为对象及其包含变量分配内存var o = &#123; a: 1, b: null&#125;;// 函数表达式也能分配一个对象obj.addEventListener("click", function()&#123; obj.style.backgroundColor = 'blue';&#125;, false); 通过函数调用的内存分配有些函数调用结果是分配对象内存：12var d = new Date();var e = document.createElement("div"); 值的使用使用值的过程实际上是对分配内存进行读取与写入的操作，这意味着可以写入一个变量或者一个对象的属性值，甚至传递函数的参数。 当内存不再需要使用时释放大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。 高级语言解释器嵌入了“垃圾回收器”，主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这个过程是一个近似的，因为要知道某块内存是否需要是 无法判定的 （无法被某种算法所解决）。 垃圾回收机制——GCJavaScript 具有自动垃圾回收机制（GC:Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。 还是上代码说明吧：123456789function fn1() &#123; var obj = &#123;name: 'yu', age: 10&#125;;&#125; function fn2() &#123; var obj = &#123;name: 'yu', age: 11&#125;; return obj;&#125;var a = fn1();var b = fn2(); 我们来看代码是如何执行的。首先定义了两个 function,分别叫做 fn1 和 fn2，当 fn1 被调用时，进入 fn1 的环境，会开辟一块内存存放对象，而当调用结束后，出了 fn1 的环境，那么该块内存会被 js 引擎中的垃圾回收器自动释放；在 fn2 被调用的过程中，返回的对象被全局变量 b 所指向，所以该块内存并不会被释放。 这里问题就出现了：到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。 标记清除js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个而变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 引用计数这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。Netscape Navigator3 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。1234567function fn() &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a;&#125; fn(); 以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄漏。在IE7与IE8上，内存直线上升。最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样12myObject.element = null;element.o = null; 内存管理1、什么时候触发垃圾回收？垃圾回收周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6 的垃圾回收是根据内存分配量运行的，当环境中存在 256 个变量、4096 个对象、64K 的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好嘛？但是如果环境中就是有这么多变量一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法玩了。 微软在 IE7 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的 15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临界条件翻倍，如果回收的内存高于 85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作智能了很多。 2、合理的 GC 方案1）、JavaScript 引擎基础 GC 方案是（simple GC）：mark and sweep（标记清除），即： 遍历所有可访问的对象。 回收已不可访问的对象。 2）、GC 的缺陷和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：GC 时，停止响应其他操作，这是为了安全考虑。而 JavaScript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应。 总结一般不用 setInterval，而用 setTimeout 的延时递归来代替 interval。setInterval 会产生回调堆积，特别是时间很短的时候。 扩展setInterval 有个很烦的地方就是当 js 主程序空闲的时候，执行代码队列里面的代码的时候，如果此时候我们有一个问题，定时器是等到回调执行完，才开始计时进行下次循环呢？还是只要一次计时完毕，插入回调之后不管回调执不执行就开始计时呢？答案显示是后者，这也就是我说 setInterval 坑的原因啊，因为这会出现一种情况，当我们插入回调的时候前队列有别的代码在执行，这时候回调肯定是不会执行的，因此如果这个时候无限定时时间到了会再次插入回调，这个时候如果发现队列中的第一次回调没有执行，那么再次插入的回调浏览器就默认取消，（这是以防出现回调连续执行多次的情况）但是这又引发了新的情况就是有些回调是不能取消掉的？]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】为什么我们放弃了 Zepto]]></title>
    <url>%2F2017%2F02%2F14%2Fwhy-we-dropped-zepto%2F</url>
    <content type="text"><![CDATA[Foundation 是 Zurb 公司开源的一套前端框架，和 Bootstrap 类似。 在漆深的洞中，聪明、强壮的雪人（雪人 – Yeti – 是 Foundation 框架的吉祥物，这里其实是暗指 Foundation 框架）听到人们的询问“Zepto 去哪儿了？”。 回顾 Foundation 版本 4 开发时，我们考虑采用 Zepto 库（jQuery 可选），主要是由于 Zepto 体积小、加载速度快。 随着时间的推移，我们发现文件体积的大小根本和执行效率没有任何比例关系。当然，必须承认，Zepto 下载的确很快。但是，一旦下载到浏览器之后，它并不像 jQuery 一样执行速度快。并且，很多第三方插件都依赖 jQuery，不支持 Zepto – 实际上，我们发现某些第三方插件和 Zepto 有冲突。 对于我们来讲，维护多套代码很不容易。例如，Zepto 缺少合适的高度计算函数，这让某些栅格（grid）的计算变得很困难。 为了解决这些问题，我们发现解决办法其实极其简单：基于 jQuery 2 构建 Foundation 版本 5。除了获得更好的执行速度和广泛的业界支持外，jQuery 2 的文档更优秀、支持也同样更好。jQuery 的 API 在各个版本是兼容的。 等一等，为了把问题讲清楚，我们还是先假定 Zepto 的执行速度可能比 jQeury 快。我们不希望犯同样的错误，因此，我们将 Zepto 和 jQuery 2 进行对比测试，测试结果是：jQuery 2 每秒执行的操作次数比 Zepto 多。这让 Foundation 版本 5 的执行效率更高，同时让所有用户感受到更好的体验。 最后，我们希望帮助大家更快速地设计优秀的产品 – 这次，我们的一点儿改变，让 Foundation 这个前端框架的速度得到大幅提升！ 译者总结：在开源的世界中，充斥着大量的开源项目，但是，只有少部分的开源项目为广大开发者所熟知并积极使用。一个好的开源项目必须有一个强大的社区和一批积极的贡献者，jQuery 就是其中一个幸运儿。 原文地址：http://zurb.com/article/1293/why-we-dropped-zepto]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】为什么一些生活中很外向开朗的人会喜欢独来独往]]></title>
    <url>%2F2016%2F12%2F24%2Fwhy-introversion-like-alone%2F</url>
    <content type="text"><![CDATA[因为他是一个内向的人。 不要怀疑，很多人都是这样。 内向的人，通过独处来恢复精力。 所以他们不是喜欢孤独，而是，孤独才是他们的常态。 他们跟别人交流、相处，其实都是在消耗精力。 下面详述： 心理学上有一个模型，叫「五因素模型」，又叫「大五人格模型」。是目前公认比较全面的人格分析模型。这个模型中，把人的性格用五个维度来区分。分别是： 外向性（Extraversion）神经质（Neuroticism）亲和性（Agreeableness）负责性（Conscientiousness）经验开放性（Openness to experience） 在「外向性」维度量表上，高得分者被认为是「外向」的，而低得分者则被认为「内向」。这里的「外向」和「内向」是有一定描述的。 外向：倾向于人际交往，热情、爱说话、充满自信、喜欢交友。在社交聚会中感到快乐。大都愿意与他人共处而不是独处。在其他人面前精力充沛，而在独处时变得平淡或感到无聊。更愿意与别人交谈而不是独自思考。等等。 内向：倾向于安静的、低调的、深思熟虑的，很少参加社交活动。他们在独自的活动中感到快乐，比如阅读、写作、绘画、编程，等等。典型内向的人大都愿意独处而不是与他人共处。习惯在一个时间只专注于一件事情。更愿意独自思考而不是与别人交谈。等等。 可以看到，区分「外向」和「内向」，最关键是，是看他是更愿意跟别人在一起，还是一个人独处。而不是开朗、活泼、健谈，这些。 因为：内向的人在跟亲密朋友相处时，也能表现出如上特质。 更深入地说，外向与内向的差异，主要在于下面三点： 经验的广度和深度外向的人倾向于广度。他们喜欢了解很多事物，对很多领域都抱有热情，喜欢交很多朋友（但也许都不够知心），喜欢尝试不同的东西。对他们而言，生活就是积累尽可能广泛的经验。 内向的人则倾向于拓展某一方面的深度。他们同样会对许多领域和事物抱有兴趣，但与外向的人不同，他们大多不会浅尝辄止，而是会深入钻研下去。他们的朋友不多，多数人跟他们只是点头之交，但他们会对朋友交心。对他们而言，太多的经验会造成压力。 对刺激的反应外向的人喜欢体验各种不同的刺激，并对刺激有较高的适应值和较高的恢复水平。也就是说，他们乐于接受刺激，并且对刺激有较高的适应能力。 内向的人内心活动水平较高，对他们而言，任何进入大脑的刺激，都会引起紧张水平的迅速升高（相对于外向的人），引起「刺激过多」的不舒服感受。 精力的来源 （这是重点）外向的人会从外部世界获得精力。对他们而言，聚会、聊天、一起做事情，都是获得精力的方式。而当他们独处时，亦即切断了他们的精力来源，很快就会感到精力耗尽和无聊疲倦。 内向的人，则是自己制造精力。对他们而言，聚会、聊天、一起做事情，都是在花费他们的精力。他们只有在独处时，才能恢复精力。所以有些人跟别人在一起时很容易疲倦，自个儿待着反而神采奕奕，就是这样。 但是，内向的人绝非都安静、低调、不善言谈，当他们精力充沛时，他可以跟你聊上几个小时，眉飞色舞。同样，外向的人也绝非一定开朗活泼。当他精力耗尽时，同样会一蹶不振。 关键只在于精力的水平，以及恢复精力的方式。 这里给一张图，帮助大家理解： 作者：Lachel原文：https://www.zhihu.com/question/24303670]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
</search>